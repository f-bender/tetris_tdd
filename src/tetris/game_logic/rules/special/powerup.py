import logging
import random
from typing import override

import numpy as np

from tetris.game_logic.action_counter import ActionCounter
from tetris.game_logic.components.board import Board
from tetris.game_logic.interfaces.callback import Callback
from tetris.game_logic.interfaces.pub_sub import Publisher
from tetris.game_logic.interfaces.rule import Rule
from tetris.game_logic.rules.core.spawn_drop_merge.spawn import SpawnStrategy, SpawnStrategyImpl
from tetris.game_logic.rules.messages import PowerupTTLsMessage

_LOGGER = logging.getLogger(__name__)


# Note: Protocols (like Rule and SpawnStrategy) need to go last for MRO reasons
class PowerupRule(Publisher, Callback, Rule, SpawnStrategy):
    _POWERUP_SLOT_OFFSET = Board.MAX_REGULAR_CELL_VALUE + 1

    def __init__(
        self,
        inner_spawn_strategy: SpawnStrategy | None = None,
        *,
        powerup_spawn_probability: float = 0.04,
        # 10-20 seconds at 60 FPS
        min_ttl_frames: int = 600,
        max_ttl_frames: int = 1200,
    ) -> None:
        super().__init__()
        # note: np.uint8 is the dtype used by the board
        self._powerup_ttls = np.zeros(np.iinfo(np.uint8).max + 1, dtype=np.uint16)
        self._spawn_strategy = inner_spawn_strategy or SpawnStrategyImpl()
        self._powerup_spawn_probability = powerup_spawn_probability

        self._min_ttl_frames = min_ttl_frames
        self._max_ttl_frames = max_ttl_frames

    @override
    def apply(self, frame_counter: int, action_counter: ActionCounter, board: Board) -> None:
        """Decrease the TTL of all power-ups by 1. Remove power-ups with TTL 0."""
        powerups_before = self._powerup_ttls > 0
        self._powerup_ttls[powerups_before] -= 1
        powerups_after = self._powerup_ttls > 0

        self.notify_subscribers(
            PowerupTTLsMessage(
                powerup_ttls={int(powerup): int(self._powerup_ttls[powerup]) for powerup in np.where(powerups_after)[0]}
            )
        )

        just_decayed_powerups = np.where(powerups_before & ~powerups_after)[0]

        # note: ghost block doesn't need to be considered as it should never be present in the actual board (view), just
        # in the array generated by as_array(include_ghost=True)
        board_view = board.array_view_without_active_block()
        board_view[np.isin(board_view, just_decayed_powerups)] %= self._POWERUP_SLOT_OFFSET

        if board.active_block is not None:
            active_block_cells = board.active_block.block.cells
            active_block_cells[np.isin(active_block_cells, just_decayed_powerups)] %= self._POWERUP_SLOT_OFFSET

    @override
    def spawn(self, board: Board) -> None:
        self._spawn_strategy.spawn(board)
        if random.random() > self._powerup_spawn_probability:
            return

        assert board.active_block is not None

        used_powerup_slots = set(np.where(self._powerup_ttls > 0)[0])

        new_powerup_slot = np.max(board.active_block.block.cells) + self._POWERUP_SLOT_OFFSET
        while new_powerup_slot in used_powerup_slots:
            new_powerup_slot += self._POWERUP_SLOT_OFFSET
            if new_powerup_slot >= Board.GHOST_BLOCK_CELL_VALUE:
                _LOGGER.warning("No available power-up slots! Not spawning a power-up.")
                return

        powerup_position = random.choice(list(zip(*np.nonzero(board.active_block.block.cells), strict=True)))
        board.active_block.block.cells[powerup_position] = new_powerup_slot

        self._powerup_ttls[new_powerup_slot] = random.randint(self._min_ttl_frames, self._max_ttl_frames)

    @override
    def on_game_start(self) -> None:
        self._powerup_ttls[...] = 0
