import logging
import random
from itertools import chain
from typing import NamedTuple, override

import numpy as np
from numpy.typing import NDArray

from tetris.game_logic.action_counter import ActionCounter
from tetris.game_logic.components.board import Board
from tetris.game_logic.interfaces.callback import Callback
from tetris.game_logic.interfaces.pub_sub import Publisher, Subscriber
from tetris.game_logic.interfaces.rule import Rule
from tetris.game_logic.rules.core.spawn.spawn import SpawnRule
from tetris.game_logic.rules.messages import PowerupTTLsMessage, SpawnMessage
from tetris.game_logic.rules.special.powerup_effect import PowerupEffectManager

_LOGGER = logging.getLogger(__name__)


# Note: Protocols (like Rule) need to go last for MRO reasons
class PowerupRule(Publisher, Subscriber, Callback, Rule):
    POWERUP_SLOT_OFFSET = Board.MAX_REGULAR_CELL_VALUE + 1

    def __init__(
        self,
        *,
        powerup_spawn_probability: float = 0.04,
        # 10-20 seconds at 60 FPS
        min_ttl_frames: int = 600,
        max_ttl_frames: int = 1200,
    ) -> None:
        super().__init__()
        # note: np.uint8 is the dtype used by the board
        self._powerup_ttls = np.zeros(np.iinfo(np.uint8).max + 1, dtype=np.uint16)
        self._powerup_spawn_probability = powerup_spawn_probability

        self._min_ttl_frames = min_ttl_frames
        self._max_ttl_frames = max_ttl_frames

        self._should_spawn = False

        self._powerup_effect_manager = PowerupEffectManager()

    @override
    def apply(self, frame_counter: int, action_counter: ActionCounter, board: Board) -> None:
        """Decrease the TTL of all power-ups by 1. Remove power-ups with TTL 0."""
        if self._should_spawn:
            self._should_spawn = False
            self._spawn_powerup(board)

        powerups_before = self._powerup_ttls > 0
        self._powerup_ttls[powerups_before] -= 1
        powerups_after = self._powerup_ttls > 0

        self._decay_powerups_in_board(board=board, just_decayed_powerups=np.where(powerups_before & ~powerups_after)[0])

        registered_powerup_slots = set(np.where(powerups_after)[0])
        actually_present_powerup_slots = {
            i
            for i in chain(
                np.unique(board.array_view_without_active_block()),
                np.unique(board.active_block.block.cells) if board.active_block is not None else [],
            )
            if Board.MIN_POWERUP_CELL_VALUE <= i <= Board.MAX_POWERUP_CELL_VALUE
        }
        assert actually_present_powerup_slots <= registered_powerup_slots

        self.notify_subscribers(
            PowerupTTLsMessage(
                powerup_ttls={
                    int(powerup): int(self._powerup_ttls[powerup]) for powerup in actually_present_powerup_slots
                }
            )
        )

        just_triggered_powerups = registered_powerup_slots - actually_present_powerup_slots
        for slot in just_triggered_powerups:
            self._powerup_effect_manager.trigger_random_effect()
            self._powerup_ttls[slot] = 0

        self._powerup_effect_manager.apply(frame_counter, action_counter, board)

    def _decay_powerups_in_board(self, board: Board, just_decayed_powerups: NDArray[np.intp]) -> None:
        # note: ghost block doesn't need to be considered as it should never be present in the actual board (view), just
        # in the array generated by as_array(include_ghost=True)
        board_view = board.array_view_without_active_block()
        board_view[np.isin(board_view, just_decayed_powerups)] %= self.POWERUP_SLOT_OFFSET

        if board.active_block is not None:
            active_block_cells = board.active_block.block.cells
            active_block_cells[np.isin(active_block_cells, just_decayed_powerups)] %= self.POWERUP_SLOT_OFFSET

    @override
    def should_be_subscribed_to(self, publisher: Publisher) -> bool:
        return isinstance(publisher, SpawnRule) and publisher.game_index == self.game_index

    @override
    def verify_subscriptions(self, publishers: list[Publisher]) -> None:
        if not any(isinstance(p, SpawnRule) for p in publishers):
            msg = f"{type(self).__name__} of game {self.game_index} is not subscribed to a SpawnRule: {publishers}"
            raise RuntimeError(msg)

    @override
    def notify(self, message: NamedTuple) -> None:
        if isinstance(message, SpawnMessage):
            self._should_spawn = True

    def _spawn_powerup(self, board: Board) -> None:
        if random.random() > self._powerup_spawn_probability:
            return

        assert board.active_block is not None

        used_powerup_slots = set(np.where(self._powerup_ttls > 0)[0])

        new_powerup_slot = np.max(board.active_block.block.cells) + self.POWERUP_SLOT_OFFSET
        while new_powerup_slot in used_powerup_slots:
            new_powerup_slot += self.POWERUP_SLOT_OFFSET
            if new_powerup_slot > Board.MAX_POWERUP_CELL_VALUE:
                _LOGGER.warning("No available power-up slots! Not spawning a power-up.")
                return

        powerup_position = random.choice(list(zip(*np.nonzero(board.active_block.block.cells), strict=True)))
        board.active_block.block.cells[powerup_position] = new_powerup_slot

        self._powerup_ttls[new_powerup_slot] = random.randint(self._min_ttl_frames, self._max_ttl_frames)

        self.notify_subscribers(
            PowerupTTLsMessage(
                powerup_ttls={
                    int(powerup): int(self._powerup_ttls[powerup]) for powerup in np.where(self._powerup_ttls > 0)[0]
                }
            )
        )

    @override
    def on_game_start(self) -> None:
        self._powerup_ttls[...] = 0
